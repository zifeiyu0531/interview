## 什么是JVM
Java程序的跨平台特性主要是指字节码文件可以在任何具有JVM的计算机或者电子设备上运行，JVM中的Java解释器负责将字节码文件解释成为特定的机器码进行运行。因此在运行时，Java源程序需要通过编译器编译成为.class文件。
JVM是JRE的一部分。它是一个虚构出来的计算机。JVM有自己完善的硬件架构，如处理器、堆栈、寄存器等，还具有相应的指令系统。Java语言最重要的特点就是跨平台运行。使用JVM就是为了支持与操作系统无关，实现跨平台。

## JVM内存模型
![](pic/memory.png)
#### 栈区
栈分为java`虚拟机栈`和`本地方法栈`
1. 重点是Java虚拟机栈，它是线程`私有`的，生命周期与线程相同。
2. 每个方法执行都会创建一个`栈帧`，用于存放局部变量表，操作栈，动态链接，方法出口等。每个方法从被调用，直到被执行完。对应着一个栈帧在虚拟机中从入栈到出栈的过程。
3. 通常说的栈就是指局部变量表部分，存放编译期间可知的8种基本数据类型，及对象引用和指令地址。局部变量表是在编译期间完成分配，当进入一个方法时，这个栈中的局部变量分配内存大小是确定的。
4. 本地方法栈为虚拟机使用到本地方法服务(native)JNI
#### 堆区
1. 堆被所有线程`共享`区域，在虚拟机启动时创建，唯一目的存放`对象`实例。
2. 堆区是`gc`的主要区域，通常情况下分为两个区块：`年轻代`和`老年代`。更细一点年轻代又分为Eden区，放新创建对象，From survivor 和 To survivor 保存gc后幸存下的对象，默认情况下各自占比 8:1:1。
#### 方法区：
1. 被所有线程`共享`区域，用于存放已被虚拟机加载的类信息、常量、静态变量等数据。被《Java虚拟机规范》描述为堆的一个逻辑部分(非堆)。习惯是也叫它`永久代`(元空间)
2. 垃圾回收很少光顾这个区域，不过也是需要回收的，主要针对常量池回收，类型卸载。
3. 常量池具有一定的动态性，里面可以存放编译期生成的常量；运行期间的常量也可以添加进入常量池中，比如string的intern() 方法。
#### 程序计数器：
1. 当前线程所执行的`行号`指示器。通过改变计数器的值来确定下一条`指令`，比如循环，分支，跳转，异常处理，线程恢复等都是依赖计数器来完成。
2. Java虚拟机多线程是通过线程轮流切换并分配处理器执行时间的方式实现的。为了线程切换能恢复到正确的位置，每条线程都需要一个独立的程序计数器，所以它是线程`私有`的。

## JVM垃圾回收算法
**标记–清除算法**
标记：遍历内存区域，对需要回收的对象打上标记。
清除：再次遍历内存，对已经标记过的内存进行回收。
**标记–复制算法（年轻代）**
将内存划分为等大的两块，每次只使用其中的一块。当一块用完了，触发GC时，将该块中存活的对象复制到另一块区域，然后一次性清理掉这块没有用的内存。下次触发GC时将那块中存活的的又复制到这块，然后抹掉那块，循环往复。
**标记–整理算法（老年代）**
标记：对需要回收的进行标记
整理：让存活的对象，向内存的一端移动，然后直接清理掉没有用的内存。

## GC分类

## GC的判定方法
**引用计数算法**
在`对象头`中分配一个空间来保存该对象被引用的`次数`。如果该对象被其它对象引用，则它的引用计数加一，如果删除对该对象的引用，那么它的引用计数就减一，当该对象的引用计数为0时发生Minor GC，那么该对象就会被回收。
**引用链**
确定一系列的GC Root的对象作为起点，从这些节点向下搜索，搜索的路径称为引用链（Reference Chain），当一个对象`无法`通过引用链连向GC Root的话证明此对象是不可用的

## GC收集器
#### CMS收集器
基于**标记-清除**算法
**过程**：初始标记 → 并发标记 → 重新标记 → 并发清理
初始标记、重新标记这两个步骤仍然需要“stop the world”，初始标记仅仅只是标记一下GC Roots能`直接`关联到的对象，速度很快，并发标记阶段就是进行GC Roots Tracing，而重新标记阶段则是为了`修正`并发标记期间因用户程序继续运作而导致标记产生表动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长点，但远比并发标记的时间短。
![](pic/cms.png)
**优点**
并发收集、低停顿
**缺点**
1. CMS收集器对CPU资源非常敏感。在并发阶段，它虽然不会导致用户线程停顿，但是会因为占用了一部分线程而导致应用程序变慢，总吞吐量会降低。
2. CMS收集器无法处理浮动垃圾
浮动垃圾：由于CMS并发清理阶段用户线程还在运行着，伴随着程序运行自然就会有新的垃圾不断产生，这部分垃圾出现的标记过程之后，CMS无法在当次收集中处理掉它们，只好留待下一次GC中再清理。这些垃圾就是“浮动垃圾”。
3. CMS是一款“标记--清除”算法实现的收集器，容易出现大量空间碎片。
#### G1收集器
基于**标记-整理**算法
**过程**：初始标记 → 并发标记 → 最终标记 → 筛选回收
初始标记仅仅只是标记一下GC Roots能直接关联到的对象，这个阶段需要停顿线程，但耗时很短；并发标记从GC Root开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象，这阶段耗时较长，但可与用户程序并发执行；最终标记对用户线程做一个短暂的暂停，用于处理并发标记阶段仍遗留下来的最后少量对象；筛选回收负责更新Region的统计数据，对各个Region的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，可以自由选择任意多个Region构成回收集，然后把决定回收的那一部分Region的存活对象复制到空的Region中，再清理掉整个旧Region的全部空间。这里的操作涉及存活对象的移动，是必须暂停用户线程，由多个收集器线程并行完成的。
![](pic/g1.png)
**特点**
1. 并行于并发：G1能充分利用CPU、多核环境下的硬件优势，使用多个CPU(CPU或者CPU核心)来缩短stop-The-World停顿时间。
2. 分代收集：G1将新生代，老年代的物理空间划分取消了。取而代之的是，G1算法将堆划分为若干个区域(Region)，它仍然属于分代收集器。不过，这些区域的一部分包含新生代，新生代的垃圾收集依然将存活对象拷贝到老年代或者Survivor空间。老年代也分成很多区域，G1收集器通过将对象从一个区域复制到另外一个区域，完成了清理工作。
3. 空间整合：与CMS的`标记--清理`算法不同，G1从整体来看是基于`标记--整理`算法实现的收集器；从局部上来看是基于`标记--复制`算法实现的。
4. 可预测的停顿：这是G1相对于CMS的另一个大优势，降低停顿时间是G1和CMS共同的关注点，但G1除了追求低停顿外，还能建立`可预测`的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，

## GC触发条件
**Minor GC触发条件**
* eden区满时，触发MinorGC。即申请一个对象时，发现eden区不够用，则触发一次Minor GC。

**Full GC触发条件**
* 老生代空间不够分配新的内存
* Minor GC前，eden space和from space区大小大于to space且大于老年代内存，触发Full GC。

## 对象创建、内存分配
#### 对象创建方法
JVM遇到一条`new`指令时，首先检查这个指令的参数是否能在`常量池`中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、连接和初始化过。如果没有，那必须先执行相应的类的加载过程。
#### 对象的内存分配
对象所需内存的大小在`类加载完成后`便完全确定（对象内存布局），为对象分配空间的任务等同于把一块确定大小的内存从Java堆中划分出来。
**指针碰撞**(标记整理)
所有用过的内存在一边，空闲内存在另一边，中间放着一个指针作为`分界点`的指示器，分配内存就是把指针往空闲内存那边挪一段与对象大小相等的距离。
**空闲列表**(标记清除)
虚拟机维护一个`列表`，记录哪些内存是可用的，分配的时候从列表中找到一块足够大的空间划分给对象，并更新列表。

## 内存分配机制
**栈上分配**
JVM通过`逃逸分析`确保对象不会被方法外部所引用，JVM不会创建该对象，而是将该对象`成员变量`分解若干个被这个方法使用的成员变量所代替，这些代替的成员变量在`栈帧或寄存器`上分配空间。
**堆分配**
1. `大对象`直接进入老年代：需要连续空间内存的对象(字符串、数组)，为了避免对象在S0-S1之间复制效率低下的问题
2. `长期存活的对象`进入老年代：内存回收的时候必须要识别哪些对象应该在新生代，那些对象在老年代。这里判断的重要依据就是GC对象的年龄，Young GC过后，年轻代依然存活的对象如果年龄达到了JVM所规定的GC年龄，则会被移动到老年代中。
3. 对象`动态年龄`判断：当前放对象的Survivor区域里(其中一块区域，放对象的那块s区)，一批对象的总大小大于这块Survivor区域内存大小的`50%`，那么此时大于等于这批对象年龄`最大值`的对象，就可以直接进入老年代了。动态年龄判断机制一般是在Young GC之后触发的
4. 老年代空间`分配担保`机制：年轻代每次minor gc之前JVM都会计算下老年代`剩余可用空间`，如果这个可用空间小于年轻代里现有的所有对象大小之和(包括垃圾对象)，就会触发一次`Full GC`，回收完还是没有足够空间存放新的对象就会发生`OOM`

## 对象的访问定位
Java是通过虚拟机栈中的局部变量表中的reference数据来操作Java堆上的具体对象。但reference只是虚拟机规范中规定指向一个对象的`引用`，它并没有定义这个引用通过何种方式去定位、访问堆中的对象的具体位置，所以对象访问方法也取决于虚拟机的实现而定的。目前主流的访问方式有使用`句柄`和`直接指针`两种。
#### 句柄访问
如果使用句柄访问，Java`堆`中将会划分出一块儿内存作为`句柄池`，reference中存储的就是对象的句柄地址，而句柄中包含了`对象实例数据`和`对象类型数据`的具体地址信息。实际上是采用了句柄池这样一个中间介质进行了`两次指针定位`，有效的避免了对象的移动或改变直接导致reference本身发生改变。句柄访问方式如下图所示：
![](pic/handle.png)
使用句柄访问最大的好处就是reference中存储的是`稳定`的句柄地址，在对象回收过程中或者其它对象需要移动的时，只会改变句柄中的实例数据的指针，而reference本身不需要做任何修改。
#### 直接指针访问
如果使用直接指针访问，那么Java堆对象的布局必须考虑如何放置访问`类型数据`的相关信息，而reference中存储的直接就是`对象地址`，而不再是句柄地址信息，相当于在reference与对象地址信息直接少了句柄池这样一个中间地址，reference中直接存储的就是对象地址。
![](pic/direct.png)
这种定位方式也就导致了在对象被移动时，reference本身必须发生`改变`。但是我们都知道，使用句柄访问方式时，相当于进行了两次指针定位，而直接指针访问方式恰好节省了这一次指针定位的`时间开销`，由于对象的访问在Java中非常的频繁，时间开销的减少也是一种可观的执行成本。例如，常见的HotSpot虚拟机就使用的是直接指针访问方式。

## 类加载机制 — 双亲委派
![](pic/classload.png)
如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求`委托给父类`的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式
**优点**
1. 带有优先级的层次关系，通过这种层级关可以避免类的重复加载
2. 安全因素，java核心api中定义类型不会被随意替换，

## 类加载的过程
1. **加载**：根据查找路径找到相应的class文件，然后导入。类的加载方式分为隐式加载和显示加载两种。`隐式加载`指的是程序在使用new关键词创建对象时，会隐式的调用类的加载器把对应的类加载到jvm中。`显示加载`指的是通过直接调class.forName方法来把所需的类加载到jvm中。
2. **验证**：检查加载的class文件的`正确性`。
3. **准备**：给类中的静态变量分配`内存空间`，设置变量`初始值`。
4. **解析**：虚拟机将常量池中的`符号引用`替换成`直接引用`的过程。符号引用就理解为一个标示，而在直接引用直接指向内存中的地址。
5. **初始化**：对`静态变量`和`静态代码块`执行初始化工作。

## 主动引用、被动引用
**主动引用（会引起类的初始化）**
* 虚拟机启动时先初始化`main`方法所在的类
* `new`一个类的对象
* 调用类的`静态`成员(除`final`)和静态方法
* 对类进行`反射`调用
* 初始化一个类若其`父类`没被初始化，则先会初始化它的父类

**被动引用（不会引起类的初始化）**
* 通过子类引用父类的静态变量，只有`父类`会被初始化
* `数组`定义引用不会触发类的初始化
* 引用`常量`(常量在链接阶段已经存入类的常量池中了)

## JDBC破坏双亲委派机制
JDBC的Driver接口定义在JDK中，其实现由各个数据库的服务商来提供， DriverManager类中要加载各个实现了Driver接口的类，然后进行管理，但是DriverManager位于JAVA_HOME中jre/lib/rt.jar 包，由BootStrap类加载器加载，而其Driver接口的实现类是位于服务商提供的Jar包，根据类加载机制，当被装载的类引用了另外一个类的时候，虚拟机就会使用装载第一个类的类装载器装载被引用的类。也就是说`BootStrap类加载器`还要去加载jar包中的Driver接口的实现类。我们知道，BootStrap类加载器默认只负责加载JAVA_HOME中jre/lib/rt.jar 里所有的class，所以需要由子类加载器去加载Driver实现，这就破坏了双亲委派模型。在启动类加载器中有方法获取应用程序类加载器，然后通过它去加载就可以了。这就是所谓的线程上下文加载器。

## JVM监控工具
#### JPS
![](pic/jps.png)
**使用场景** ：查看当前机器的所有Java进程信息（可追踪到应用进程ID 、启动类名、文件路径。）

**格式** ：jps 【选项 】 [hostid]
[hostid] 远程地址,可选参数，指定特定主机的IP或者域名，也可以指定具体协议端口，不指定则查看当前机器的相关信息，hostid所指机器必须开启jstatd服务。

**常用命令** ：jps -l
查看当前虚拟器运行的进程，输出主类全路径名称。
#### Jstat
![](pic/jstat.png)
```
S0C 和 S0U    //S0区的总内存大小和已使用的内存大小。
S1C: 和S1U   //S1区的总内存大小和已使用的内存大小。。
EC 和 EU     //Eden区的总内存大小 和已使用的内存大小。
OC和OU       //Old区的总内存大小 和已使用的内存大小。
MC和MU       //方法区的总内存大小 和已使用的内存大小。
CCSC和CCSU   //压缩类空间大小 和已使用的内存大小。
YGC和 YGCT   //Young GC 的总次数 和消耗总时间。
FGC和 FGCT   //Full Gc的总次数和消耗总时间。
GCT         //所有GC的消耗时间。
```
**使用场景** ：用于查看各个功能和区域的统计信息（如：类加载、编译相关信息统计，各个内存区域GC概况和统计）

**格式** ： jstat 【选项】 【进程ID】 [间隔时间 ] [查询次数]
[间隔时间 ] 可选参数，每隔多长时间输出一次信息，单位为毫秒。
[查询次数] 可选参数，总共输出多少次信息。
![](pic/jstat2.png)

**常用指令** ：jstat -gc PID
查看即时内存使用情况、垃圾回收统计信息，监视Java堆状况，包括Eden区、2个Survivor区、老年代.永久代等的容量，已用空间，垃圾收集时间合计等信息。用于分析GC情况。
#### Jinfo
![](pic/jinfo.png)
**使用场景** ：查看和调整JVM启动和运行参数。

**格式** ：jinfo 【选项】【具体选项参数名】【进程ID】

- 案例一：查看JVM整个系统参数信息
输出16462进程jvm的全部参数和系统属性
    ```shell
    jinfo 16462
    ```
- 案列二：查看某个具体参数
查看老年代内存大小
    ```shell
    jinfo -flag OldSize 16462
    ```
- 案列三：启用某个配置
启动GC日志打印
    ```shell
    jinfo -flag +PrintGCDetails 16462
    ```
- 案例四：修改某个参数值
修改当堆内存对象所占空间超过80%时进行扩容
    ```shell
    jinfo -flag MaxHeapFreeRatio=80 16462
    ```   
#### Jmap
**使用场景** ：监控堆内存使用情况和对象占用情况， 生成堆内存快照文件，查看堆内存区域配置信息。

**格式** ：jmap 【选项】【进程ID】
![](pic/jmap.png)
- 案例一：查看堆内存的配置和使用情况
    ```shell
    jmap -heap 18230
    ```
- 案例二：查看JVM中对应类型对象的数量、占用内存情况
    ```shell
    jmap -histo 18230 | sort -n -r -k 2 | head -10  # 统计实例最多的类 前十位有哪些
    jmap -histo 18230 | sort -n -r -k 3 | head -10  # 统计合计容量前十的类有哪些  
    ```
- 案例三：dump 堆快照
    ```shell
    jmap -dump:live, format=b, file=/home/myheapdump.hprof 18230
    # live   加上live代表只dump存活的对象
    # fomat  格式
    # filie  导出的文件名
    # 18230  java进程ID
    ```
#### Jstack
**使用场景** ：查看JVM线程信息 和生成线程快照。

**格式** ：jstack 【选项】【进程ID】
![](pic/jstack.png)
- 案例一：打印堆栈线程信息 ，输出到文件
    ```shell
    jstack -l 871055 > jstack.prof
    ```
#### 第三方在线监控工具(Arthas)
Arthas 是Alibaba开源的Java诊断工具，它可以帮助我们解决在线环境的以下问题
1. 监控到JVM的实时运行状态（涵盖Jps ,jstat ,jinfo ,jstack ,部分Jmap功能）。
2. 在不需要重新部署服务的情况下修改业务代码。
3. 以局视角来查看系统的运行状况。
- 案例一：查看系统实时运行状态（dashboard）
在控制台输入dashboard 回车后会看到下图对应的信息，这里主要展示了当前监控的进程信息、包括 实时的线程信息、内存分配和使用状态信息、系统环境信息。
![](pic/arthas1.png)
- 案例二：查看应用线程信息（thread）
thead 可现实应用的运行线程情况，功能和jstack类似。在控制台输入thread 可显示当前应用运行的线程信息。
![](pic/arthas2.png)

## JVM内存溢出
#### 程序计数器
**作用**：指向当前线程下一条需要执行的字节码指令的地址
**内存溢出**：不会发生
#### 虚拟机栈
**作用**：由栈帧组成、每个栈帧代表一次方法调用，其包含存储变量表、操作数栈和方法出口三个部分，方法执行完成后该栈帧将被弹出。
**内存溢出**：`StackOverflowError`和`OutOfMemoryError`。
**溢出原因**：
- `StackOverflowError`：如果请求的栈的深度大于虚拟机所允许的深度，将会抛出这个异常，如果使用虚拟机默认参数，一般达到1000到2000这样的深度没有问题。
- `OutOfMemoryError`：因为除掉堆内存和方法区容量，剩下的内存由虚拟机栈和本地方法栈瓜分，如果剩下的内存不足以满足更多的工作线程的运行、或者不足以拓展虚拟机栈的时候，就会抛出OutOfMemoryError异常。

**解决方法**：
`StackOverflowError`：
1. 首先栈溢出会输出异常信息，根据信息查看对应的方法调用是否出现无限调用、或者栈帧过大等代码逻辑上的问题，通过修改代码逻辑解决；
2. 如果确确实实需要更大的栈容量，可以检查并调大栈容量：-Xss16m。

`OutOfMemoryError`：
1. 首先检查是否创建过多的线程，减少线程数
2. 可以通过“减少最大堆容量”或“减少栈容量”来解决。
#### 本地方法栈
**作用**：与虚拟机栈唯一的不同是虚拟机栈执行的是java方法，而本地方法栈执行的是本地的C/C++方法
**内存溢出**：`StackOverflowError`和`OutOfMemoryError`
**溢出原因**：同虚拟机栈
**解决方法**：同虚拟机栈
#### 堆
**作用**：所有线程共享，存放对象实例
**内存溢出**：`OutOfMemoryError:Java heap space`
**溢出原因**：堆中没有足够内存完成实例分配，并且无法继续拓展时
**解决方法**：
1. 内存泄露检查：首先通过“内存溢出快照 + MAT等分析工具”，分析是否存在内存泄露现象，检查时可以怀疑的点比如集合、第三方库如数据库连接的使用、new关键字相关等。
2. 如果没有内存泄露，那么就是内存溢出，所有对象却是都还需要存活，这个时候就只能调大堆内存了：-Xms和-Xmx。
#### 方法区
**作用**：所有线程共享，存放已加载的class信息、常量、静态变量和即时编译后的代码
**内存溢出**：`OutOfMemoryError:PermGen space`
**溢出原因**：方法区没有足够内存完成内存分配存放运行时新加载的class信息
**解决方法**：
1. 内存泄露检查：检查是否加载过多class文件(jar文件)，或者重复加载相同的class文件(jar文件)多次
2. 通过-XX:PermSize=64M -XX:MaxPermSize=128M改大方法区大小
#### 运行时常量池
**作用**：方法区的一部分，存放常量
**内存溢出**：`OutOfMemoryError:PermGen space`
**溢出原因**：方法区没有足够的内存完成内存分配，存放运行时新创建的常量，比如String类的intern()方法，其作用是如果常量池已经包含一个相同的字符串，则返回其引用，否则将此String对象包含的字符串添加到常量池中。
**解决方法**：
1. 内存泄露检查：检查是否创建过多常量
2. 通过-XX:PermSize=64M -XX:MaxPermSize=128M改大方法区大小
#### 直接内存
**作用**：不属于JVM运行时数据区，也不是虚拟机规范中定义的内存区域，JDK1.4引入的NIO中包含通道Channel和缓冲区Buffer，应用程序从通道获取数据是先经过OS的内核缓冲区，再拷贝至Buffer，因为比较耗时，所以Buffer提供了一种直接操作操作系统缓冲区的方式，即ByteBuffer.allocateDirector(size)，这个方法返回DirectByteBuffer应用就是指向这个底层存储空间关联的缓冲区，即直接内存。
**内存溢出**：`OutOfMemoryError`
**溢出原因**：JVM所需内存 + 直接内存 > 机器物理内存(或操作系统级限制)，无法动态拓展
**判断方法**：内存泄露检查：例如内存占用较高，机器性能骤降，但是通过GC信息或者jstat发现GC很少，通过jmap获得快照分析后也没发现什么异常，而程序中又直接或者间接地用到了NIO，那么和可能就是直接内存泄露了。
**解决方法**：分析NIO相关的程序逻辑解决。