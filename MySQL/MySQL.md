## 索引
索引（Index）是帮助MySQL高效获取数据的`数据结构`。
在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。
**优点**
* 有效缩短数据的检索时间
* 为用来排序或者是分组的字段添加索引可以加快分组和排序顺序

**缺点**
* 创建索引和维护索引需要时间成本、空间成本
* 会降低表的增删改的效率，因为每次增删改索引需要进行动态维护，导致时间变长

## 索引的类型
1. 普通索引（单列索引）
2. 复合索引（组合索引）
复合索引遵守“最左前缀”原则，即在查询条件中使用了复合索引的第一个字段，索引才会被使用
3. 唯一索引
和普通索引类似，主要的区别在于，唯一索引限制列的值必须唯一，但允许存在空值（只允许存在一条空值）
4. 主键索引
一个表只能有一个主键，不允许有空值。一般是在建表的时候同时创建主键索引
5. 全文索引
全文索引主要用来查找文本中的关键字，而不是直接与索引中的值相比较。

## 聚簇索引和非聚簇索引
`Innodb`使用的是`聚簇索引`，`MyISam`使用的是`非聚簇索引`
**聚簇索引**
聚簇索引就是按照每张表的`主键`构造一颗B+树，同时叶子节点中存放的就是整张表的行记录数据，也将聚集索引的叶子节点称为数据页。这个特性决定了索引组织表中`数据也是索引的一部分`，每张表只能拥有一个聚簇索引。
Innodb通过主键聚集数据，如果没有定义主键，innodb会选择非空的唯一索引代替。如果没有这样的索引，innodb会隐式的定义一个主键来作为聚簇索引。
**非聚簇索引**
将`数据存储与索引分开`结构，索引结构的叶子节点指向了数据的对应行，myisam通过key_buffer把索引先缓存到内存中，当需要访问数据时（通过索引访问数据），在内存中直接搜索索引，然后通过索引找到磁盘相应数据

## MySQL索引数据结构
#### B树
一颗`m阶`的B树（B-tree） 定义如下：
1. 每个节点最多有 `m-1` 个key；
2. 根节点至少有1个key；
3. 非根节点至少有 `(m/2)-1` 个key；(向上取整)
4. 每个节点中的key都按照从小到大的顺序排列，每个key的左子树中的所有key都小于它，而右子树中的所有key都大于它；
5. 所有叶子节点都位于`同一层`，即根节点到每个叶子节点的长度都相同。

![](./pic/btree.png)
**插入**
若插入节点的key还未“`丰满`”，则直接插入，若节点插入节点的key已“`丰满`”，则插入节点之后`分裂`，再以分裂之后的父节点看作向上层插入的节点调整，直至满足该 m 阶的B树。
**删除**
1. 若删除非叶子节点， 找`后继`节点替换之，将问题转化为删除叶子节点；
2. 若删除叶子节点，且叶子节点的key数`大于`定义中的最小值，则`直接删除`即可，无需调整，
3. 若删除叶子节点，且叶子节点的key数`等于`定义中的最小值，则将节点删除，此时树肯定需要`调整`，即：
   * 若删除节点的`相邻兄弟节点`的key数`大于`定义中的最小值，则父节点的1个key`下移`与待删除的节点合并，相邻兄弟节点的1个key`上移`与父节点合并，完成调整；
   * 若删除节点的`相邻兄弟节点`的key数`等于`定义的最小值，则父节点的1个key`下移`与待删除的节点及相邻兄弟节点，`三者合并`成一个节点，若下移1个key后的父节点的key数陷入“贫穷”，则将`父节点`看作当前待删除的节点，重复判断。
#### B+树
1. 有` k `个子节点的节点必然有` k `个key；
2. 非叶子节点仅具有`索引`作用，跟记录有关的信息均存放在`叶子节点`中。
3. 树的所有叶子节点构成一个`有序链表`，可以按照key排序的次序遍历全部记录。

![](./pic/b+tree.png)
**优点**
* 由于B+树在内部节点上不包含数据信息，因此在内存页中能够存放更多的key。数据存放的更加`紧密`，具有更好的空间局部性。因此访问叶子节点上关联的数据也具有更好的缓存命中率。
* B+树的叶子结点都是`相链`的，因此对整棵树的遍历只需要一次线性遍历叶子结点即可。而且由于数据顺序排列并且相连，所以便于`区间查找和搜索`。而B树则需要进行每一层的递归遍历，相邻的元素可能在内存中不相邻，所以缓存命中性没有B+树好。

## 脏读、不可重复读、幻读
**脏读**
某个事务已更新一份数据，另一个事务在此时读取了同一份数据，由于某些原因，前一个`回滚`了操作，则后一个事务所读取的数据就会是不正确的。
**不可重复读**
在一个事务的两次查询之中数据不一致，这可能是两次查询`过程中间`插入了一个事务更新的原有的数据。
**幻读**
事务A 按照一定条件进行数据读取， 期间事务B 插入了相同搜索条件的新数据，事务A再次按照原先条件进行读取时，发现了事务B 新插入的数据 称为幻读。
-第1类丢失更新：事务A撤销时，把已经提交的事务B的更新数据覆盖了。
-第2类丢失更新：事务A覆盖事务B已经提交的数据，造成事务B所做的操作丢失。

## MySQL隔离级别
|    隔离级别     |  脏读  | 不可重复读 |  幻读  |                                                                                       |
| :-------------: | :----: | :--------: | :----: | :-----------------------------------------------------------------------------------: |
| READ UNCOMMITED |  允许  |    允许    |  允许  |                      所有事务都可以看到其他未提交事务的执行结果                       |
| READ COMMITTED  | 不允许 |    允许    |  允许  |                        一个事务只能看见已经提交事务所做的改变                         |
| REPEATABLE READ | 不允许 |   不允许   |  允许  | MySQL的默认事务隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行 |
|  SERIALIZABLE   | 不允许 |   不允许   | 不允许 |        每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争         |
**解决脏读**
修改时加`排他锁`(写锁)，直到`事务提交`后才释放，读取时加`共享锁`(读锁)，其他事务只能读取，不能再有更新操作 。防止脏读。
**解决不可重复读**
innodb引擎采用了`mvcc`（多版本并发控制）来解决不可重复读问题。mvcc是利用在每条数据后面加了隐藏的两列（`创建版本号`和`删除版本号`）当执行查询的时, 当前查询版本号>= 创建版本号 并且 >删除版本号 , MVCC可以在大多数情况下代替行级锁,使用MVCC,能降低其系统开销。
**解决幻读**
Mysql官方给出的幻读解释是：只要在一个事务中，第二次select`多出了row`就算幻读。

## MVCC多版本并发控制
多版本并发控制（MVCC）是一种用来解决`不可重复读`的并发控制，MVCC为事务分配单向增长的时间戳，为每个修改保存一个`版本`，版本与事务时间戳关联，读操作只读该事务开始前的数据库的快照。 
一个支持MVCC的数据库，在更新某些数据时，并非使用新数据覆盖旧数据，而是标记旧数据是`过时`的，同时在其他地方新增一个数据版本。因此，同一份数据有`多个版本`存储，但只有一个是最新的。
InnoDB的MVCC，通过在每行记录后面保存两个隐藏的列来实现：一个保存了行的`创建时间`，一个保存行的`过期时间`（删除时间），当然，这里的时间并不是时间戳，而是`系统版本号`，每开始一个新的事务，系统版本号就会递增
**select操作**
InnoDB只查找创建版本`早于`（包含`等于`）当前事务版本的数据行。可以确保事务读取的行，要么是事务开始前就已存在，或者事务自身插入或修改的记录。
行的删除版本要么`未定义`，要么`大于`当前事务版本号。可以确保事务读取的行，在事务开始之前未删除。
**insert操作**
将新插入的行保存当前版本号为创建时间。
**delete操作**
将删除的行保存当前版本号为过期时间。
**update操作**
变为`insert`和`delete`操作的组合，insert的行保存当前版本号为`创建时间`，delete则保存当前版本号到原来的行作为`过期时间`。
由于旧数据并不真正的删除，所以必须对这些数据进行清理，innodb会开启一个后台线程执行清理工作，具体的规则是将删除`版本号小于当前系统版本`的行删除，这个过程叫做purge。

## 数据库事务
数据库事务(transaction)是访问并可能操作各种数据项的一个数据库`操作序列`，这些操作要么全部执行,要么全部不执行，是一个`不可分割`的工作单位。事务由事务开始与事务结束之间执行的全部数据库操作组成。
**事务的ACID属性**
**原子性**(atomicity)
整个事务中的所有操作，要么全部完成，要么全部不完成，不可能停滞在中间某个环节。 事务在执行过程中发生错误，会被`回滚`（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。 
**一致性**(consistency)
在事务开始之前和事务结束以后，数据库数据的`一致性约束`没有被破坏。例如：现有完整性约束 A+B=100，如果一个事务改变了 A，那么必须得改变 B，使得事务结束后依然满足 A+B=100，否则事务失败。
**隔离性**(isolation)
事务的执行不受`其他事务`的干扰，
**持久性**(durability)
对于任意已提交事务，系统必须保证该事务对数据库的改变不被丢失，即使数据库出现故障。

## MySQL存储引擎InnoDB和MyISAM的区别
1. InnoDB支持事务，MyISAM不支持，对于InnoDB每一条SQL语言都默认`封装成事务`，自动提交，这样会影响速度，所以最好把多条SQL语言放在begin和commit之间，组成一个事务； 
2. InnoDB支持`外键`，而MyISAM不支持。
3. InnoDB是`聚簇索引`（数据库表行中数据的物理顺序与键值的逻辑（索引）顺序相同），使用B+Tree作为索引结构，数据文件是和（主键）索引绑在一起的（表数据文件本身就是按B+Tree组织的一个索引结构），必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。MyISAM是`非聚簇索引`，也是使用B+Tree作为索引结构，索引和数据文件是`分离`的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。也就是说：InnoDB的B+树主键索引的叶子节点就是数据文件，辅助索引的叶子节点是主键的值；而MyISAM的B+树主键索引和辅助索引的叶子节点都是数据文件的地址指针。
4. InnoDB不保存表的`具体行数`，执行select count(*) from table时需要全表扫描。而MyISAM用一个变量保存了整个表的行数。
5. InnoDB支持表、行(默认)级锁，而MyISAM支持表级锁
* 如果是`读多写少`的项目,可以考虑使用MyISAM,MyISAM索引和数据是分开的，而且其索引是压缩的，可以更好地利用内存。所以它的查询性能明显优于INNODB。压缩后的索引也能节约一些磁盘空间。MyISAM拥有全文索引的功能，这可以极大地优化LIKE查询的效率。
* 如果你的应用程序一定要使用事务，毫无疑问你要选择INNODB引擎

## sql优化
**从数据库设计方面考虑**
* 表与表之间的业务联系要明确
* 表字段尽量使用数值型：
* 属性尽量使用定长
* 建立合理的索引

**从SQL语句优化方面考虑**
* 尽量将要输出的字段写出来（不要SELECT *）
* 合理使用连表查询
* 查询的时候要注意是否走索引
* 使用索引遵循最佳左前缀

**读写分离与分库分表**

## MySQL有哪些锁
#### 按锁粒度分类
**行级锁**
行级锁是mysql中锁定`粒度最细`的一种锁。表示只针对当前操作的行进行加锁。行级锁能大大减少数据库操作的冲突，其加锁粒度最小，但加锁的开销也最大。行级锁分为共享锁和排他锁
特点：开销大，加锁慢，会出现`死锁`。发生锁冲突的概率最低，并发度也最高。
**表级锁**
表级锁是mysql中锁定`粒度最大`的一种锁，表示对当前操作的整张表加锁，它实现简单，资源消耗较少，被大部分mysql引擎支持。最常使用的MyISAM与InnoDB都支持表级锁定。表级锁定分为表共享读锁（共享锁）与表独占写锁（排他锁）
特点：开销小，加锁快，不会出现死锁。发生锁冲突的概率最高，并发度也最低。
**页级锁**
页级锁是 MySQL 中锁定粒度介于行级锁和表级锁`中间`的一种锁。表级锁速度快，但冲突多，行级冲突少，但速度慢。因此，采取了折衷的页级锁，一次锁定`相邻的一组`记录。BDB 支持页级锁。
特点：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。
#### 按锁级别分类
**共享锁**
共享锁又称`读锁`，是读取操作创建的锁。其他用户可以并发读取数据，但任何事务都不能对数据进行修改（获取数据上的排他锁），直到已释放所有共享锁。
如果事务T对数据A加上共享锁后，则其他事务只能对A再加共享锁，不能加排他锁。获准共享锁的事务`只能读数据`，不能修改数据。
用法：SELECT … LOCK IN SHARE MODE;
**排他锁**
排他锁又称`写锁`、独占锁，如果事务T对数据A加上排他锁后，则其他事务不能再对A加任何类型的封锁。获准排他锁的事务既能读数据，又能修改数据。
用法：SELECT … FOR UPDATE;

## SQL语句的执行过程
一条查询的sql语句先执行的是`FROM`，负责把数据库的表文件加载到`内存`中去；`WHERE`会把所示表中的数据进行过滤，取出`符合条件`的记录行，生成一张`临时表`；`GROUP BY`会把临时表`切分`成若干临时表；`ORDER BY`对以上的临时表进行`排序`；LIMIT取排序后的数据。

## 数据库三范式
1NF：每个属性都不可再分
2NF：属性完全依赖于主键。 
3NF：属性不依赖于其它非主属性。
