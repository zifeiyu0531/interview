## DNS工作原理
递归 + 迭代
请求主机 → 本地域名服务器 → 根域名服务器 → 顶级域名服务器 → 权威域名服务器
![](./pic/dns.png)

## TCP / IP 四层模型
- 应用层：HTTP、FTP、DNS、SMTP、Telnet
- 传输层：TCP、UDP
- 网络层：IP
- 网络接口层：ARP、RARP

## TCP与UDP的区别
UDP协议和TCP协议都是传输层协议。
1. TCP提供的是面向连接，可靠的字节流服务。即客户和服务器交换数据前，必须现在双方之间建立一个TCP连接，之后才能传输数据。并且提供超时重发，数据校验，流量控制，拥塞控制等功能，保证数据能从一端传到另一端。
2. UDP是一个简单的面向数据报的运输层协议。它不提供可靠性，只是把应用程序传给IP层的数据报发送出去，但是不能保证它们能到达目的地。由于UDP在传输数据报前不用再客户和服务器之间建立一个连接，且没有超时重发等机制，所以传输速度很快。

## TCP的三次握手与四次挥手，TIMEWAIT的作用
![](./pic/tcp1.png)
为什么需要三次握手呢？为了防止`已失效`的连接请求报文段突然又传送到了服务端，因而产生错误。
比如：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的`滞留`了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段，但是server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求，于是就向client发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了，由于client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据，但server却以为新的运输连接已经建立，并一直等待client发来数据。所以没有采用“三次握手”，这种情况下server的很多资源就白白浪费掉了。
![](./pic/tcp2.png)
为什么需要四次挥手呢？TCP是`全双工`模式，当client发出FIN报文段时，只是表示client已经没有数据要发送了，client告诉server，它的数据已经全部发送完毕了；但是，这个时候client还是可以接受来server的数据；当server返回ACK报文段时，表示它已经知道client没有数据发送了，但是server还是可以发送数据到client的；当server也发送了FIN报文段时，这个时候就表示server也没有数据要发送了，就会告诉client，我也没有数据要发送了，如果收到client确认报文段，之后彼此就会中断这次TCP连接。

TCP协议规定,主动关闭连接的一方要处于`TIME_ WAIT`状态,等待两个`MSL`(最大报文生存周期)的时间后才能回到`CLOSED`状态。TIME_WAIT持续存在2MSL的话，就能保证在两个传输方向上的尚未被接收或迟到的报文段都已经消失，同时如果最后一个ACK丢失，TIME_ WAIT状态可以重传最后的确认报文。

## TCP如何实现可靠传输
1. 应用数据被分割成 TCP 认为最适合发送的`数据块`。 
2. TCP 给发送的每一个包进行`编号`，接收方对数据包进行`排序`，把有序数据传送给应用层。 
3. 校验和： TCP将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。 
4. TCP 的接收端会丢弃重复的数据。 
5. 流量控制： TCP连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 
6. 拥塞控制：当网络拥塞时，减少数据的发送。 
7. 停止等待协议：也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。

## TCP流量控制 - 滑动窗口协议
1. 发送端和接收端分别设定发送窗口和接收窗口。 
2. 三次握手的时候，客户端把自己的缓冲区大小也就是`窗口大小`发送给服务器，服务器回应时也将窗口大小发送给客户端，服务器客户端都知道了彼此的窗口大小。 
3. 比如主机A的发送窗口大小为5，主机A可以向主机B发送5个单元，如果B缓冲区满了，A就要等待B确认才能继续发送数据。 
4. 如果缓冲区中有1个报文被进程读取，主机B就会回复`ACK`给主机A，接收窗口向前滑动，报文中窗口大小为1，就说明A还可以发送1个单元的数据，发送窗口向前滑动，之后等待主机B的确认报文。只有接收窗口向前滑动并发送了确认时，发送窗口才能向前滑动。
![](./pic/window.png)
#### 回退N帧协议
在发送完一个帧后，不用停下来等待确认，而是可以连续发送多个数据帧。这样就减少了等待时间，整个通信的通吞吐量提高。 如果前一个帧在超时时间内未得到确认，就认为丢失或被破坏，需要重发出错帧及其后面的所有数据帧。这样有可能又把正确的数据帧重传一遍，降低了传送效率。
#### 选择重传协议
后退n协议的另外一个问题是，当有错误帧出现后，总是要重发该帧之后的所有帧，毫无疑问在网络不是很好的情况下会进一步恶化网络状况，重传协议便是用来解决这个问题。原理也很简单，接收端总会缓存所有收到的帧，当某个帧出现错误时，只会要求重传这一个帧，只有当某个序号后的所有帧都正确收到后，才会一起提交给高层应用。重传协议的缺点在于接受端需要更多的`缓存`。

## TCP拥塞控制
#### 慢启动
在执行慢启动算法时，发送方每收到一个对新报文段的ACK时，就把拥塞窗口`cwnd`的值加一，然后开始下一轮的传输，当拥塞窗口`cwnd`增长到慢启动门限值`ssthresh`时，就进入`拥塞避免`状态。
#### 拥塞避免
每个传输轮次，拥塞窗口`cwnd`只能线性加一，而不是像慢开始算法时，每个传输轮次，拥塞窗口`cwnd`按指数增长。
![](./pic/congestion1.png)
#### 快速重传
假设3号报文丢失，接收方不会发送针对该报文的ACK报文给发送方，发送方还可以将发送窗口内的4号数据报文段发送出去，接收方收到后，发现这不是按序到达的报文段，因此给发送方发送针对2号报文段的`重复ACK`，表明我现在希望收到的是3号报文段，但是我没有收到3号报文段，而收到了未按序到达的报文段。发送方还可以将发送窗口中的5、6号报文段发送出去.
此时，发送方收到了累计`3个连续`的针对2号报文段的`重复ACK`，立即重传3号报文段，接收方收到后，给发送方发回针对6号报文的ACK，表明，序号到6为至的报文都收到了，这样就不会造成发送方对3号报文的超时重传，而是提早收到了重传。
#### 快速恢复
发送方一旦收到`3个重复ACK`，就会执行快速恢复算法：将`ssthresh`和`cwnd`的值调整为当前窗口的`一半`，然后进入拥塞避免状态
![](./pic/congestion2.png)

## HTTP状态码含义
![](./pic/httpcode.png)
**301** `Moved Permanently`：永久性重定向，表示请求的资源被分配了新的URL，之后应使用更改的URL
**400** `Bad Request`：表示请求报文中存在语法错误
**404** `Not Found`：表示服务器上无法找到请求的资源
**500** `Inter Server Error`：表示服务器在执行请求时发生了错误，也有可能是web应用存在的bug或某些临时的错误时
**503** `Server Unavailable`：表示服务器暂时处于超负载或正在进行停机维护，无法处理请求

## HTTP请求的几种类型
1. **GET**：向特定的资源发出请求。
2. **POST**：向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的创建和/或已有资源的修改。
3. **PUT**：向指定资源位置上传其最新内容。
4. **DELETE**：请求服务器删除Request-URI所标识的资源。

## HTTP1.0、1.1、2.0的区别 
#### HTTP1.0 和 HTTP1.1
1. **长连接**
HTTP1.1支持长连接和请求的流水线处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启长连接`keep-alive`，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。HTTP1.0需要使用keep-alive参数来告知服务器端要建立一个长连接。
2. **节约带宽**
HTTP1.0中存在一些浪费带宽的现象，例如客户端只是需要某个对象的`一部分`，而服务器却将整个对象送过来了，并且不支持`断点续传`功能。HTTP1.1支持只发送header信息（不带任何body信息），如果服务器认为客户端有权限请求服务器，则返回100，客户端接收到100才开始把请求body发送到服务器；如果返回401，客户端就可以不用发送请求body了节约了带宽。
#### HTTP1.1 和 HTTP2.0
1. **多路复用**
HTTP2.0使用了多路复用的技术，做到同一个连接`并发`处理多个请求，而且并发请求的数量比HTTP1.1大了好几个数量级。HTTP1.1也可以多建立几个TCP连接，来支持处理更多并发的请求，但是创建TCP连接本身也是有开销的。
![](./pic/http2.png)
3. **头部数据压缩**
在HTTP1.1中，HTTP请求和响应都是由`状态行`、`请求/响应头部`、`消息主体`三部分组成。一般而言，消息主体都会经过gzip压缩，或者本身传输的就是压缩过后的二进制文件，但状态行和头部却没有经过任何压缩，直接以`纯文本`传输。随着Web功能越来越复杂，每个页面产生的请求数也越来越多，导致消耗在头部的流量越来越多，尤其是每次都要传输UserAgent、Cookie这类不会频繁变动的内容，完全是一种浪费。
HTTP1.1不支持header数据的压缩，HTTP2.0使用`HPACK`算法对header的数据进行压缩，这样数据体积小了，在网络上传输就会更快。
4. **服务器推送**
服务端推送是一种在客户端请求之前发送数据的机制。网页使用了许多资源：HTML、样式表、脚本、图片等等。在HTTP1.1中这些资源每一个都必须明确地请求。这是一个很慢的过程。浏览器从获取HTML开始，然后在它解析和评估页面的时候，增量地获取更多的资源。因为服务器必须等待浏览器做每一个请求，网络经常是空闲的和未充分使用的。
为了改善延迟，HTTP2.0引入了server push，它允许服务端`推送`资源给浏览器，在浏览器明确地请求之前，免得客户端再次创建连接发送请求到服务器端获取。这样客户端可以直接从本地加载这些资源，不用再通过网络。
![](./pic/http2push.png)

## 电脑上访问一个网页，整个过程是怎么样的
1. 浏览器查询`DNS`，获取域名对应的`IP`地址
2. 浏览器获得域名对应的IP地址以后，浏览器向服务器请求`建立链接`，发起三次握手
3. TCP/IP链接建立起来后，浏览器向服务器发送`HTTP请求`；
4. 服务器接收到这个请求，并根据路径参数映射到特定的请求处理器进行处理，并将处理结果及相应的视图返回给浏览器；
5. 浏览器`解析并渲染`视图，若遇到对js文件、css文件及图片等静态资源的引用，则重复上述步骤并向服务器请求这些资源；
6. 浏览器根据其请求到的资源、数据渲染页面，最终向用户呈现一个完整的页面。

## 路由器和交换机区别
1. 路由器实现了不同`网络之间`的数据转发，交换机实现了特定`网络内`的数据交换
2. 交换机转发所依据的对象时：`MAC地址`。（物理地址）
3. 路由转发所依据的对象是：`IP地址`。（网络地址）

## ARP 和 RARP
1. **ARP**
ARP（Address Resolution Protocol，地址解析协议）是将`IP`地址解析为以太网`MAC`地址（物理地址）的协议。在局域网中，当主机或其他网络设备有数据要发送给另一个主机或设备时，它必须知道对方的网络层地址（即IP地址）。但是仅仅有IP地址是不够的，因为IP数据报文必须封装成帧才能通过物理网络发送。因此发送方还需要有接收方的物理地址，也就需要一个从IP地址到物理地址的映射，ARP就是实现这么功能的协议。
2. **RARP**
RARP为逆地址解析协议，作用与ARP相反，用于将`MAC`地址转换为`IP`地址。

## HTTP 和 HTTPS
HTTPS是一种通过计算机网络进行安全通信的传输协议，经由HTTP进行通信，利用`SSL/TLS`建立全信道，加密数据包。HTTPS使用的主要目的是提供对网站服务器的身份认证，同时保护交换数据的隐私与完整性。
HTTPS的特点：
**内容加密**：采用混合加密技术，中间者无法直接查看明文内容
**验证身份**：通过证书认证客户端访问的是自己的服务器
**保护数据完整性**：防止传输的内容被中间人冒充或者篡改
#### SSL建立连接过程
![](./pic/ssl.png)
1. client向server发送请求https://baidu.com，然后连接到server的`443`端口，发送的信息主要是`随机值1`和客户端支持的`加密算法`。
2. server接收到信息之后给予client响应握手信息，包括`随机值2`和匹配好的`协商加密算法`，这个加密算法一定是client发送给server加密算法的子集。
3. 随即server给client发送第二个响应报文是`数字证书`。这套证书其实就是一对公钥和私钥。传送证书，这个证书其实就是`公钥`，只是包含了很多信息，如证书的颁发机构、过期时间、服务端的公钥、第三方证书认证机构(CA)的签名、服务端的域名信息等内容。
4. 客户端`解析证书`，这部分工作是由客户端的`TLS`来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等等，如果发现异常，则会弹出一个警告框，提示证书存在问题。如果证书没有问题，那么就生成一个随机值（`预主秘钥`）。
5. 客户端认证证书通过之后，接下来是通过`随机值1`、`随机值2`和`预主秘钥`组装`会话秘钥`。然后通过证书的公钥`加密`会话秘钥。
6. 传送加密信息，这部分传送的是用证书加密后的`会话秘钥`，目的就是让服务端使用秘钥解密得到随机值1、随机值2和预主秘钥。
7. 服务端`解密`得到随机值1、随机值2和预主秘钥，然后组装`会话秘钥`，跟客户端会话秘钥相同。
8. 客户端通过会话秘钥加密一条消息发送给服务端，主要`验证`服务端是否正常接受客户端加密的消息。
9. 同样服务端也会通过会话秘钥加密一条消息回传给客户端，如果客户端能够正常接受的话表明SSL层连接建立完成了。

## 转发和重定向
**forward(转发)** 指服务器`内部`的转发，服务器直接访问目标地址的URL，把那个URL的响应内容读取过来，而客户端并不知道，因此在客户端的地址栏中不会显示转向后的地址，还是原来的地址。由于整个转发的过程用的是同一个Request，因此forward会将Request的信息带到被定向的JSP或Servlet中使用。
**redirect(重定向)** 客户端的重定向，是完全的`跳转`，即客户端浏览器会获取到跳转后的地址，然后重新发送请求，因此浏览器中显示跳转后的地址。同时，这种方式比forward方式多了一次网络请求，因此效率要低于forward方式。
