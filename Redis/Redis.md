## Redis数据类型
**五大基本数据类型**
字符串(STRING)、列表(LIST)、哈希(HASH)、集合(SET)、有序集合(ZSET)
**三种特殊数据类型**
地理位置(Geospatial)、基数统计(Hyperloglog)、位图(Bitmap)

## Redis数据结构
#### 简单动态字符串SDS
![](./pic/sds.png)
大多数情况下，Redis使用SDS作为字符串的表示
和C字符串相比，SDS的**优点**：
1. 常数复杂度获取字符串长度
SDS的`len`属性记录了字符串的长度，而C字符串想要知道长度需要进行一次遍历操作
2. 杜绝缓冲区溢出
C字符串创建之初已经分配好了空间，当使用strcat的时候就有可能发生溢出；SDS在修改的时候会检查空间，在需要的时候自动扩展
3. 减少修改字符串长度时所需的内存重新分配次数
C字符串每次修改都要对底层的数组进行扩缩容；**空间预分配**：SDS的`free`属性记录了未使用空间大小，如果修改后SDS小于1MB，会再给SDS分配和len属性同等的未使用空间，如果大于1MB，就分配1MB的未使用空间。**惰性空间释放**：在字符串缩短的时候多余的空间并不释放，而是在`free`属性中记录，SDS提供了API可以在需要的时候真正释放SDS的未使用空间
4. 二进制安全
C字符串使用空字符`'\0'`作为结束，只能保存文本数据；SDS可以直接将空字符保存，因为SDS使用len属性而不是空字符判断结束，所以可以直接保存二进制数据
#### 链表
当一个`列表键`包含的元素数量`比较多`，又或者列表键中的元素都是`比较长`的字符串时，Redis就会使用链表作为列表键的底层实现
![](./pic/list.png)
1. 双端：链表节点listNode带有prev和next指针，指向前置和后置节点
2. 无环：表头的prev和表尾的next都指向null
3. 带表头指针和表尾指针：list结构带有head指针和tail指针，获取表头和表尾节点的复杂度均是O(1)
4. 带长度计数器：list结构len属性用于计数
#### 字典
当一个`哈希键`包含的键值对`比较多`，又或者键值对中的元素都是`比较长`的字符串时，Redis就会使用字典作为哈希键的底层实现
![](./pic/dict.png)
1. Redis中的字典使用哈希表作为底层实现，每个字典带有两个哈希表，一个平时使用，另一个仅在进行`rehash`时使用
2. 哈希表具体的hash过程为：先使用具体的hash算法计算出key的hash值，在用`hash & sizemask`计算出索引位置
3. 哈希表使用`链地址法`解决键的hash冲突，同一个索引多个键值对会形成一个单向链表，新节点加入会插入到`表头`的位置
4. 对哈希表进行扩缩容的操作时，要先将 ht[0] 现有的键值对`rehash`到ht [1] 里，当全部迁移完成后，将 ht[1] 设置为 ht[0] ，并在 ht[1] 处再新建一个空白hash表。这个过程不是一次性完成，而是`渐进式`完成的
5. 负载因子大于`1`的时候进行扩容、小于`0.1`的时候进行缩容
6. 渐进式rehash：设置`rehashidx=0`，当程序每次对字典进行`增删改查`的操作的时候，除了完成该操作，还会将 ht[1] 中所有`rehashidx`位置的键值对rehash到 ht[0] 中，并将`rehashidx+1`
#### 跳表
当一个`有序集合`包含的元素数量`比较多`，又或者有序集合中元素的成员是`比较长`的字符串时, Redis就会使用跳表来作为有序集合健的底层实现
![](./pic/skiplist.png)
1. Redis的跳表由`zskiplistNode`和`zskiplist`两个结构定义，其中 zskiplistNode结构用于表示跳表节点，而zskiplist结构则用于保存跳表节点的相关信息，比如节点的数量，以及指向表头节点和表尾节点的指针等等。
2. 每次`创建`一个新跳表节点的时候，程序都根据`幂次定律`(powerlaw，越大的数出现的概率越小)随机生成一个介于`1到32`之间的值作为level数组的大小，这个大小就是跳表节点的`层高`
3. 在跳表中，多个节点可以包含相同的`分值`，但节点成员对象必须是唯一的。节点按各自所保存的`分值`从小到大排序，分值相同时，按照成员对象大小排序。
#### 整数集合
当一个`集合键`只包含`整数`值元素，且这个集合的元素`数量不多`时，Redis就会使用整数集合作为集合键的底层实现

